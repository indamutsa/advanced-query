/**
 * generated by Xtext 2.25.0
 */
package com.arsene.dsl.query.generator;

import com.arsene.dsl.query.queryDsl.And;
import com.arsene.dsl.query.queryDsl.ArithmeticSigned;
import com.arsene.dsl.query.queryDsl.Assignment;
import com.arsene.dsl.query.queryDsl.BoolConstant;
import com.arsene.dsl.query.queryDsl.Comparison;
import com.arsene.dsl.query.queryDsl.Equality;
import com.arsene.dsl.query.queryDsl.Expo;
import com.arsene.dsl.query.queryDsl.Expression;
import com.arsene.dsl.query.queryDsl.Instruction;
import com.arsene.dsl.query.queryDsl.IntConstant;
import com.arsene.dsl.query.queryDsl.Minus;
import com.arsene.dsl.query.queryDsl.Mod;
import com.arsene.dsl.query.queryDsl.Model;
import com.arsene.dsl.query.queryDsl.MulOrDiv;
import com.arsene.dsl.query.queryDsl.Not;
import com.arsene.dsl.query.queryDsl.Or;
import com.arsene.dsl.query.queryDsl.Plus;
import com.arsene.dsl.query.queryDsl.Primary;
import com.arsene.dsl.query.queryDsl.PrintCommand;
import com.arsene.dsl.query.queryDsl.StringConstant;
import com.arsene.dsl.query.queryDsl.VarRef;
import com.arsene.dsl.query.queryDsl.VariableDeclaration;
import com.google.common.collect.Iterables;
import java.util.Arrays;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class QueryDslGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    String generatedCode = "";
    EObject _head = IterableExtensions.<EObject>head(resource.getContents());
    Model model = ((Model) _head);
    Iterable<Instruction> _filter = Iterables.<Instruction>filter(model.getInstructions(), Instruction.class);
    for (final Instruction e : _filter) {
      String _generatedCode = generatedCode;
      CharSequence _compile = this.compile(e);
      String _plus = (_compile + "\n");
      generatedCode = (_generatedCode + _plus);
    }
    fsa.generateFile("generated_code.js", generatedCode);
  }
  
  protected CharSequence _compile(final VariableDeclaration it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("var ");
    String _name = it.getName();
    _builder.append(_name);
    _builder.append(" = ");
    Expression _initExp = it.getInitExp();
    CharSequence _compile = null;
    if (_initExp!=null) {
      _compile=this.compile(_initExp);
    }
    _builder.append(_compile);
    return _builder;
  }
  
  protected CharSequence _compile(final VarRef it) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = it.getRef().getName();
    _builder.append(_name);
    return _builder;
  }
  
  protected CharSequence _compile(final Assignment it) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = it.getV().getRef().getName();
    _builder.append(_name);
    _builder.append(" = ");
    CharSequence _compile = this.compile(it.getExp());
    _builder.append(_compile);
    return _builder;
  }
  
  protected CharSequence _compile(final And it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    _builder.append("&&");
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final Or it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    _builder.append("||");
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final Plus it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    _builder.append(" + ");
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final Minus it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    _builder.append(" - ");
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final Expo it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    _builder.append(" ** ");
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final Mod it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    _builder.append(" % ");
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final MulOrDiv it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    _builder.append(" ");
    String _op = it.getOp();
    _builder.append(_op);
    _builder.append(" ");
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final IntConstant it) {
    StringConcatenation _builder = new StringConcatenation();
    String _string = Integer.valueOf(it.getValue()).toString();
    _builder.append(_string);
    return _builder;
  }
  
  protected CharSequence _compile(final Primary it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    CharSequence _compile = this.compile(it.getExpr());
    _builder.append(_compile);
    _builder.append(")");
    return _builder;
  }
  
  protected CharSequence _compile(final ArithmeticSigned it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("-");
    CharSequence _compile = this.compile(it.getExpression());
    _builder.append(_compile);
    return _builder;
  }
  
  protected CharSequence _compile(final Not it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("!(");
    CharSequence _compile = this.compile(it.getExpression());
    _builder.append(_compile);
    _builder.append(")");
    return _builder;
  }
  
  protected CharSequence _compile(final Equality it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    {
      boolean _equals = it.getOp().equals("==");
      if (_equals) {
        _builder.append("===");
      } else {
        _builder.append("!==");
      }
    }
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final Comparison it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    String _op = it.getOp();
    _builder.append(_op);
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final BoolConstant it) {
    StringConcatenation _builder = new StringConcatenation();
    String _value = it.getValue();
    _builder.append(_value);
    return _builder;
  }
  
  protected CharSequence _compile(final StringConstant it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\"");
    String _value = it.getValue();
    _builder.append(_value);
    _builder.append("\"");
    return _builder;
  }
  
  protected CharSequence _compile(final PrintCommand it) {
    CharSequence _xblockexpression = null;
    {
      final Function1<Expression, String> _function = (Expression p) -> {
        CharSequence _compile = this.compile(p);
        String _plus = ("(" + _compile);
        return (_plus + ")");
      };
      final String p = IterableExtensions.join(ListExtensions.<Expression, String>map(it.getParams(), _function), " + ");
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("window.printConsoleOutput(");
      _builder.append(p);
      _builder.append(")");
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  protected CharSequence _compile(final Instruction it) {
    String _xblockexpression = null;
    {
      InputOutput.<String>println("ERROR: Unsupported kind of Instruction in ExpressionsGenerator.compile()");
      _xblockexpression = "\n";
    }
    return _xblockexpression;
  }
  
  public CharSequence compile(final EObject it) {
    if (it instanceof PrintCommand) {
      return _compile((PrintCommand)it);
    } else if (it instanceof And) {
      return _compile((And)it);
    } else if (it instanceof ArithmeticSigned) {
      return _compile((ArithmeticSigned)it);
    } else if (it instanceof Assignment) {
      return _compile((Assignment)it);
    } else if (it instanceof BoolConstant) {
      return _compile((BoolConstant)it);
    } else if (it instanceof Comparison) {
      return _compile((Comparison)it);
    } else if (it instanceof Equality) {
      return _compile((Equality)it);
    } else if (it instanceof Expo) {
      return _compile((Expo)it);
    } else if (it instanceof IntConstant) {
      return _compile((IntConstant)it);
    } else if (it instanceof Minus) {
      return _compile((Minus)it);
    } else if (it instanceof Mod) {
      return _compile((Mod)it);
    } else if (it instanceof MulOrDiv) {
      return _compile((MulOrDiv)it);
    } else if (it instanceof Not) {
      return _compile((Not)it);
    } else if (it instanceof Or) {
      return _compile((Or)it);
    } else if (it instanceof Plus) {
      return _compile((Plus)it);
    } else if (it instanceof Primary) {
      return _compile((Primary)it);
    } else if (it instanceof StringConstant) {
      return _compile((StringConstant)it);
    } else if (it instanceof VarRef) {
      return _compile((VarRef)it);
    } else if (it instanceof VariableDeclaration) {
      return _compile((VariableDeclaration)it);
    } else if (it instanceof Instruction) {
      return _compile((Instruction)it);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(it).toString());
    }
  }
}
