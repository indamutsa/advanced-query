grammar com.arsene.dsl.query.QueryDsl with org.eclipse.xtext.common.Terminals

generate queryDsl "http://www.arsene.com/dsl/query/QueryDsl"


Model:
	instructions+=Instruction*
;
	
Instruction:
	VariableDeclaration
	| Assignment
	| GlobalCommand
;

VariableDeclaration:
	'var' name=ID ('=' initExp=Expression)?
;

VarRef:
	ref=[VariableDeclaration]
;

Assignment:
	v=VarRef '=' exp=Expression
;

GlobalCommand:
		{PrintCommand} 'print' params+=Expression
;

//--- Arithmetic/Logic expressions --------------------
// These are heavily inspired by the solution of Lorenzo Bettini,
// the author of "Implementing Domain-Specific Languages with Xtext and Xtend"
// Github: https://github.com/LorenzoBettini

Expression: Or;

Or returns Expression:
	And (
		{Or.left=current} "||" right=And
	)*
;

And returns Expression:
	Equality (
		{And.left=current} "&&" right=Equality
	)*
;

Equality returns Expression:
	Comparison (
		{Equality.left=current} op=("==" | "!=")
		right=Comparison
	)*
;

Comparison returns Expression:
	PlusOrMinus (
		{Comparison.left=current} op=(">=" | "<=" | ">" | "<")
		right=PlusOrMinus
	)*
;

PlusOrMinus returns Expression:
	Mod (
		({Plus.left=current} '+' | {Minus.left=current} '-')
		right=Mod
	)*
;

Mod returns Expression:
	MulOrDiv (
		({Mod.left=current} op=('mod' ))
		right=MulOrDiv
	)*
;

MulOrDiv returns Expression:
	Expo (
		({MulOrDiv.left=current} op=('*' | '/'))  
		right=Expo
	)*
;

// exponential operator
Expo returns Expression:
	Prefixed (
		({Expo.left=current} op=('^' ))  
		right=Prefixed
	)*
;

Prefixed returns Expression:
    {Not} =>"!" expression=Atomic | /* right associativity */
    {ArithmeticSigned} =>"-" expression=Atomic | /* right associativity */
    Atomic
;

Atomic returns Expression:
	  {Primary} '(' expr=Expression ')'
	| {IntConstant} value=INT
	| {BoolConstant} value=('true' | 'false')
	| {StringConstant} value=STRING
	| VarRef
;


-------------------


/*
 * generated by Xtext 2.25.0
 */
package com.arsene.dsl.query.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import com.arsene.dsl.query.queryDsl.Model
import com.arsene.dsl.query.queryDsl.Instruction
import com.arsene.dsl.query.queryDsl.And
import com.arsene.dsl.query.queryDsl.Or
import com.arsene.dsl.query.queryDsl.Plus
import com.arsene.dsl.query.queryDsl.Minus
import com.arsene.dsl.query.queryDsl.Expo
import com.arsene.dsl.query.queryDsl.Mod
import com.arsene.dsl.query.queryDsl.MulOrDiv
import com.arsene.dsl.query.queryDsl.IntConstant
import com.arsene.dsl.query.queryDsl.Primary
import com.arsene.dsl.query.queryDsl.ArithmeticSigned
import com.arsene.dsl.query.queryDsl.Not
import com.arsene.dsl.query.queryDsl.Equality
import com.arsene.dsl.query.queryDsl.Comparison
import com.arsene.dsl.query.queryDsl.BoolConstant
import com.arsene.dsl.query.queryDsl.StringConstant
import com.arsene.dsl.query.queryDsl.VariableDeclaration
import com.arsene.dsl.query.queryDsl.VarRef
import com.arsene.dsl.query.queryDsl.Assignment
import com.arsene.dsl.query.queryDsl.PrintCommand

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class QueryDslGenerator extends AbstractGenerator {
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var generatedCode= ""
		var model = resource.contents.head as Model
		
		for (e : model.instructions.filter(typeof (Instruction))) {
			generatedCode += e.compile + "\n"; 
		}
		
		fsa.generateFile("generated_code.js" , generatedCode)
	}
	
	def dispatch CharSequence compile(VariableDeclaration it) {
		'''var «name» = «initExp?.compile»'''
	}
	
	def dispatch CharSequence compile(VarRef it) {
		'''«ref.name»'''
	}
	
	def dispatch CharSequence compile(Assignment it) {
		'''«v.ref.name» = «exp.compile»'''
	}
	
	def dispatch CharSequence compile(And it) {
		'''«left.compile»&&«right.compile»'''
	}
	
	def dispatch CharSequence compile(Or it) {
		'''«left.compile»||«right.compile»'''
	}

	def dispatch CharSequence compile(Plus it) {
		'''«left.compile» + «right.compile»'''
	}
	
	def dispatch CharSequence compile(Minus it) {
		'''«left.compile» - «right.compile»'''
	}
	
	def dispatch CharSequence compile(Expo it) {
		'''«left.compile» ** «right.compile»'''
	}
	
	def dispatch CharSequence compile(Mod it) {
		'''«left.compile» % «right.compile»'''
	}
	
	def dispatch CharSequence compile(MulOrDiv it) {
		'''«left.compile» «op» «right.compile»'''
	}
	
	def dispatch CharSequence compile(IntConstant it) {
		'''«value.toString»'''
	}
	
	def dispatch CharSequence compile(Primary it) {
		'''(«expr.compile»)'''
	}
	
	def dispatch CharSequence compile(ArithmeticSigned it) {
		'''-«expression.compile»'''
	}
	
	def dispatch CharSequence compile(Not it) {
		'''!(«expression.compile»)'''
	}
	
	def dispatch CharSequence compile(Equality it) {
		'''«left.compile»«IF op.equals("==")»===«ELSE»!==«ENDIF»«right.compile»'''
	}
	
	def dispatch CharSequence compile(Comparison it) {
		'''«left.compile»«op»«right.compile»'''
	}
	
	def dispatch CharSequence compile(BoolConstant it) {
		'''«value»'''
	}
	
	def dispatch CharSequence compile(StringConstant it) {
		'''"«value»"'''
	}

	def dispatch CharSequence compile(PrintCommand it) {
		val p = params.map(p|"(" + p.compile + ")").join(' + ')
		'''window.printConsoleOutput(«p»)'''
	}
	
		
	def dispatch CharSequence compile(Instruction it) {
		println("ERROR: Unsupported kind of Instruction in ExpressionsGenerator.compile()")
		'\n'
	}
}
